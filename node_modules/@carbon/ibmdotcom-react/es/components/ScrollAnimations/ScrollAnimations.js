/**
 * Copyright IBM Corp. 2016, 2021
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */
import React, { useCallback, useEffect, useRef } from 'react';
import { breakpoints } from '@carbon/layout';
import PropTypes from 'prop-types';
import settings from 'carbon-components/es/globals/js/settings';
var prefix = settings.prefix;
/**
 * Amount of columns used for calculation.
 *
 * @private
 */

var colSpan = 3;
/**
 * Utility handles fade transition for selected elements.
 *
 * @example
 * import { ScrollAnimations } from '@carbon/ibmdotcom-react';
 * import '@carbon/ibmdotcom-styles/scss/components/scroll-into-view/_scroll-into-view.scss';
 *
 * As an example, the function can be called to target all instances of the
 * elements in a list:
 *
 * const list = '.bx--content-block, .bx--content-group';
 *
 * For default values of 400ms and 'one and done' play:
 * <ScrollAnimations selectorTargets={selectorTargets}>
 *   // some content
 * </ScrollAnimations>
 *
 * With 'continuous play' option:
 * <ScrollAnimations animation={'fade'} selectorTargets={selectorTargets} keepAnimations={true}>
 *   // some content
 * </ScrollAnimations>
 *
 * For custom delay time, set within targeted class in the application's CSS code as such:
 *
 * .bx--content-block {
 *   --#{$dds-prefix}--fade-in-out-delay: 250ms;
 * }
 *
 */

var ScrollAnimations = function ScrollAnimations(_ref) {
  var animation = _ref.animation,
      children = _ref.children,
      selectorTargets = _ref.selectorTargets,
      keepAnimations = _ref.keepAnimations;

  /**
   * Outer div component ref for using with query selector.
   *
   * @private
   */
  var componentRef = useRef(null);
  /**
   * Intersection Observer that watches outer viewport.
   *
   * @private
   */

  var rootObserver = useRef(null);
  /**
   * Intersection observer that watches the inner viewport.
   *
   * @private
   */

  var innerObserver = useRef(null);
  /**
   * Resize observer to trigger rootMargin recalculations
   *
   * @private
   */

  var resizeObserver = useRef(null);
  /**
   * Scroll animation class to be applied when element is within viewport.
   *
   * @private
   */

  var effectClass = useRef(null);
  /**
   * Scroll animation to be applied when elements are out of view.
   *
   * @private
   */

  var exitEffectClass = useRef(null);
  /**
   * Create observers upon render and update.
   */

  useEffect(function () {
    setAnimationClasses();
    rootObserver.current = new IntersectionObserver(handleExit);
    resizeObserver.current = new ResizeObserver(handleResize);

    if (selectorTargets) {
      var _componentRef$current;

      (_componentRef$current = componentRef.current) === null || _componentRef$current === void 0 ? void 0 : _componentRef$current.querySelectorAll(selectorTargets).forEach(function (item) {
        rootObserver === null || rootObserver === void 0 ? void 0 : rootObserver.current.observe(item);
      });
    }

    resizeObserver.current.observe(document.documentElement);
    return function () {
      rootObserver.current.disconnect();
      innerObserver.current.disconnect();
      resizeObserver.current.disconnect();
      rootObserver.current = null;
      innerObserver.current = null;
      resizeObserver.current = null;
    };
  }, [componentRef, selectorTargets, setAnimationClasses, handleEntrance, handleResize]);
  /**
   * Handler to add recalculated rootMargin to a new instance of
   * inner observer after clearing old one first.
   *
   * The calculation is done to retrieve the best fitting top and bottom
   * margin for the fade animation to trigger/remove from elements in a
   * user's screen.
   *
   * The resulting value is the optimal point where a user's attention will be
   * grabbed by the animation without restricting their view and perception of
   * the adopting website. The displayed elements will keep the user's attention
   * for a longer time as they scroll down the website.
   *
   * @private
   */

  var handleResize = useCallback(function () {
    if (innerObserver.current) {
      innerObserver.current.disconnect();
      innerObserver.current = null;
    }

    innerObserver.current = new IntersectionObserver(handleEntrance, {
      rootMargin: "-".concat((document.documentElement.clientHeight * colSpan / breakpoints.max.columns).toString(), "px 0px")
    });

    if (selectorTargets) {
      var _componentRef$current2;

      (_componentRef$current2 = componentRef.current) === null || _componentRef$current2 === void 0 ? void 0 : _componentRef$current2.querySelectorAll(selectorTargets).forEach(function (item) {
        innerObserver === null || innerObserver === void 0 ? void 0 : innerObserver.current.observe(item);
      });
    }
  }, [componentRef, innerObserver, selectorTargets, handleEntrance]);
  /**
   * Handler to add fade animation to element
   *
   * @param {*} records observed elements
   * @private
   *
   */

  var handleEntrance = useCallback(function (records) {
    records.forEach(function (_ref2) {
      var intersectionRatio = _ref2.intersectionRatio,
          target = _ref2.target;

      if (intersectionRatio > 0) {
        target.classList.remove(exitEffectClass.current);
        target.classList.add(effectClass.current);

        if (!keepAnimations) {
          rootObserver.current.unobserve(target);
          innerObserver.current.unobserve(target);
        }
      }
    });
  }, [keepAnimations, rootObserver, innerObserver]);
  /**
   * Handler to remove element from view
   *
   * @param {*} records observed elements
   * @private
   *
   */

  function handleExit(records) {
    records.forEach(function (_ref3) {
      var intersectionRatio = _ref3.intersectionRatio,
          target = _ref3.target;

      if (intersectionRatio == 0) {
        target.classList.remove(effectClass.current);
        target.classList.add(exitEffectClass.current);
      }
    });
  }

  var setAnimationClasses = useCallback(function () {
    switch (animation) {
      case 'slide-up':
        effectClass.current = "".concat(prefix, "--slide-in");
        exitEffectClass.current = "".concat(prefix, "--slide-up");
        break;

      case 'slide-up-right':
        effectClass.current = "".concat(prefix, "--slide-in");
        exitEffectClass.current = "".concat(prefix, "--slide-up-right");
        break;

      case 'slide-right':
        effectClass.current = "".concat(prefix, "--slide-in");
        exitEffectClass.current = "".concat(prefix, "--slide-right");
        break;

      case 'slide-down-right':
        effectClass.current = "".concat(prefix, "--slide-in");
        exitEffectClass.current = "".concat(prefix, "--slide-down-right");
        break;

      case 'slide-down':
        effectClass.current = "".concat(prefix, "--slide-in");
        exitEffectClass.current = "".concat(prefix, "--slide-down");
        break;

      case 'slide-down-left':
        effectClass.current = "".concat(prefix, "--slide-in");
        exitEffectClass.current = "".concat(prefix, "--slide-down-left");
        break;

      case 'slide-left':
        effectClass.current = "".concat(prefix, "--slide-in");
        exitEffectClass.current = "".concat(prefix, "--slide-left");
        break;

      case 'slide-up-left':
        effectClass.current = "".concat(prefix, "--slide-in");
        exitEffectClass.current = "".concat(prefix, "--slide-up-left");
        break;

      default:
        effectClass.current = "".concat(prefix, "--fade-in");
        exitEffectClass.current = "".concat(prefix, "--fade-out");
        break;
    }
  }, [animation, effectClass, exitEffectClass]);
  return /*#__PURE__*/React.createElement("div", {
    ref: componentRef
  }, children);
};

ScrollAnimations.propTypes = {
  /**
   * String that determines what effect to display
   */
  animation: PropTypes.string,

  /**
   * Component(s) to render within the component
   */
  children: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.node), PropTypes.node]).isRequired,

  /**
   * List of elements to be targeted
   */
  selectorTargets: PropTypes.string,

  /**
   * Boolean to define if animation is continuous
   */
  keepAnimations: PropTypes.bool
};
export default ScrollAnimations;