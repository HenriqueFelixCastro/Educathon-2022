import _toConsumableArray from "@babel/runtime/helpers/toConsumableArray";
import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _regeneratorRuntime from "@babel/runtime/regenerator";

/**
 * Copyright IBM Corp. 2020, 2022
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */
import axios from 'axios';
import geolocation from '../../internal/vendor/@carbon/ibmdotcom-utilities/utilities/geolocation/geolocation';
import ipcinfoCookie from '../../internal/vendor/@carbon/ibmdotcom-utilities/utilities/ipcinfoCookie/ipcinfoCookie';
import root from 'window-or-global';
/**
 * @constant {string | string} Host for the Locale API call
 * @private
 */

var _host = process && (process.env.REACT_APP_TRANSLATION_HOST || process.env.TRANSLATION_HOST) || 'https://1.www.s81c.com';
/**
 * Sets the default location if nothing is returned
 *
 * @type {object}
 * @private
 */


var _localeDefault = {
  lc: 'en',
  cc: 'us'
};
/**
 * Default display name for lang combination
 *
 * @type {string}
 * @private
 */

var _localeNameDefault = 'United States â€” English';
/**
 * Locale API endpoint
 *
 * @type {string}
 * @private
 */

var _endpoint = "".concat(_host, "/common/js/dynamicnav/www/countrylist/jsononly");
/**
 * Configuration for axios
 *
 * @type {{headers: {'Content-Type': string}}}
 * @private
 */


var _axiosConfig = {
  headers: {
    'Content-Type': 'application/json; charset=utf-8'
  }
};
/**
 * Session Storage key for country list
 *
 * @type {string}
 * @private
 */

var _sessionListKey = 'dds-countrylist';
/**
 * Two hours in milliseconds to compare session timestamp.
 *
 * @type {number}
 * @private
 */

var _twoHours = 60 * 60 * 2000;
/**
 * Use the <html> lang attr to determine a return locale object
 *
 * @type {object}
 * @private
 */


var _getLocaleByLangAttr = function _getLocaleByLangAttr() {
  var _root$document, _root$document$docume;

  if ((_root$document = root.document) === null || _root$document === void 0 ? void 0 : (_root$document$docume = _root$document.documentElement) === null || _root$document$docume === void 0 ? void 0 : _root$document$docume.lang) {
    var lang = root.document.documentElement.lang.toLowerCase();

    if (lang.indexOf('-') === -1) {
      return {
        lc: lang
      };
    } else {
      var codes = lang.split('-');
      return {
        cc: codes[1],
        lc: codes[0]
      };
    }
  } else {
    return _localeDefault;
  }
};
/**
 * The cache for in-flight or resolved requests for the country list, keyed by the initiating locale.
 *
 * @type {object}
 * @private
 */


var _requestsList = {};
/**
 * Return a locale object based on the DDO API, or "false"
 * so the consumer can decide what to do next
 *
 * @type {(object | boolean)}
 * @private
 */

function _getLocaleFromDDO() {
  var _ddoLocal$page, _ddoLocal$page$pageIn;

  var ddoLocal = Object.assign({}, root.digitalData || {});

  if ((_ddoLocal$page = ddoLocal.page) === null || _ddoLocal$page === void 0 ? void 0 : (_ddoLocal$page$pageIn = _ddoLocal$page.pageInfo) === null || _ddoLocal$page$pageIn === void 0 ? void 0 : _ddoLocal$page$pageIn.language) {
    var _ddoLocal$page2, _ddoLocal$page2$pageI, _ddoLocal$page3, _ddoLocal$page3$pageI, _ddoLocal$page3$pageI2;

    var lang = {}; // if DDO language contains both lc & cc (ie. en-US)

    if (((_ddoLocal$page2 = ddoLocal.page) === null || _ddoLocal$page2 === void 0 ? void 0 : (_ddoLocal$page2$pageI = _ddoLocal$page2.pageInfo) === null || _ddoLocal$page2$pageI === void 0 ? void 0 : _ddoLocal$page2$pageI.language.includes('-')) && ((_ddoLocal$page3 = ddoLocal.page) === null || _ddoLocal$page3 === void 0 ? void 0 : (_ddoLocal$page3$pageI = _ddoLocal$page3.pageInfo) === null || _ddoLocal$page3$pageI === void 0 ? void 0 : (_ddoLocal$page3$pageI2 = _ddoLocal$page3$pageI.ibm) === null || _ddoLocal$page3$pageI2 === void 0 ? void 0 : _ddoLocal$page3$pageI2.country)) {
      // Set proper LC for us to use.
      lang.lc = ddoLocal.page.pageInfo.language.substring(0, 2).toLowerCase();
      lang.cc = ddoLocal.page.pageInfo.ibm.country.toLowerCase().trim(); // If there are multiple countries use just the first one for the CC value

      if (lang.cc.indexOf(',') > -1) lang.cc = lang.cc.substring(0, lang.cc.indexOf(',')).trim(); // Gb will be uk elsewhere

      if (lang.cc === 'gb') {
        lang.cc = 'uk';
      } // Map worldwide (ZZ) pages to US


      if (lang.cc === 'zz') {
        lang.cc = 'us';
      }
    } else {
      // set lc with just the language code
      lang.lc = ddoLocal.page.pageInfo.language.substring(0, 2).toLowerCase();
    }

    return lang;
  }

  return false;
}
/**
 * Locale API class with method of fetching user's locale for
 * ibm.com
 */


var LocaleAPI = /*#__PURE__*/function () {
  function LocaleAPI() {
    _classCallCheck(this, LocaleAPI);
  }

  _createClass(LocaleAPI, null, [{
    key: "clearCache",

    /**
     * Clears the cache.
     */
    value: function clearCache() {
      if (typeof sessionStorage !== 'undefined') {
        Object.keys(_requestsList).forEach(function (key) {
          return delete _requestsList[key];
        });

        for (var i = 0; i < sessionStorage.length; ++i) {
          var key = sessionStorage.key(i);

          if (key.indexOf(_sessionListKey) === 0) {
            sessionStorage.removeItem(key);
          }
        }
      }
    }
    /**
     * Gets the user's locale
     *
     * Grab the locale from the `lang` attribute from html, else
     * check if ipcinfo cookie exists (ipcinfoCookie util)
     * if not, retrieve the user's locale through geolocation util + gets user's
     * browser language preference then set the cookie
     *
     * @returns {object} object with lc and cc
     *
     * @example
     * import { LocaleAPI } from '@carbon/ibmdotcom-services';
     *
     * async function getLocale() {
     *   const locale = await LocaleAPI.getLocale();
     *   return locale;
     * }
     */

  }, {
    key: "getLocale",
    value: function () {
      var _getLocale = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
        var cookie, lang, cc, _lang, lc, list, verifiedCodes;

        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                cookie = ipcinfoCookie.get();
                _context.next = 3;
                return this.getLang();

              case 3:
                lang = _context.sent;

                if (!lang) {
                  _context.next = 8;
                  break;
                }

                return _context.abrupt("return", lang);

              case 8:
                if (!(cookie && cookie.cc && cookie.lc)) {
                  _context.next = 14;
                  break;
                }

                _context.next = 11;
                return this.getList(cookie);

              case 11:
                return _context.abrupt("return", cookie);

              case 14:
                _context.next = 16;
                return geolocation();

              case 16:
                cc = _context.sent;

                /**
                 * get language preference from browser
                 * can return in either 'en-US' format or 'en' so will need to extract language only
                 */
                _lang = root.navigator.language;
                lc = _lang.split('-')[0];

                if (!(cc && lc)) {
                  _context.next = 26;
                  break;
                }

                _context.next = 22;
                return this.getList({
                  cc: cc,
                  lc: lc
                });

              case 22:
                list = _context.sent;
                verifiedCodes = this.verifyLocale(cc, lc, list); // set the ipcInfo cookie

                ipcinfoCookie.set(verifiedCodes);
                return _context.abrupt("return", verifiedCodes);

              case 26:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function getLocale() {
        return _getLocale.apply(this, arguments);
      }

      return getLocale;
    }()
    /**
     * Checks for DDO object to return the correct cc and lc
     * Otherwise gets those values from the <html> lang attribute
     *
     * @returns {object} locale object
     *
     * @example
     * import { LocaleAPI } from '@carbon/ibmdotcom-services';
     *
     * function async getLocale() {
     *    const locale = await LocaleAPI.getLang();
     * }
     */

  }, {
    key: "getLang",
    value: function getLang() {
      return new Promise(function (resolve) {
        var getLocaleFromDDO = _getLocaleFromDDO();

        if (getLocaleFromDDO) {
          resolve(getLocaleFromDDO);
        } else {
          resolve(_getLocaleByLangAttr());
        }
      });
    }
    /**
     * This fetches the language display name based on language/locale combo
     *
     * @param {object} langCode lang code with cc and lc
     *
     * @returns {Promise<string>} Display name of locale/language
     */

  }, {
    key: "getLangDisplay",
    value: function () {
      var _getLangDisplay = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(langCode) {
        var lang, list, countries, location;
        return _regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (!langCode) {
                  _context2.next = 4;
                  break;
                }

                _context2.t0 = langCode;
                _context2.next = 7;
                break;

              case 4:
                _context2.next = 6;
                return this.getLang();

              case 6:
                _context2.t0 = _context2.sent;

              case 7:
                lang = _context2.t0;
                _context2.next = 10;
                return this.getList(lang);

              case 10:
                list = _context2.sent;
                // combines the countryList arrays
                countries = [];
                list.regionList.forEach(function (region) {
                  countries = countries.concat(region.countryList);
                }); // get match for countries with multiple languages

                location = countries.filter(function (country) {
                  var htmlLang = country.locale.findIndex(function (loc) {
                    return loc[0] === "".concat(lang.lc, "-").concat(lang.cc);
                  });

                  if (htmlLang !== -1) {
                    var _country$locale;

                    var localeMatch = country.locale.filter(function (l) {
                      return l.includes("".concat(lang.lc, "-").concat(lang.cc));
                    });

                    (_country$locale = country.locale).splice.apply(_country$locale, [0, country.locale.length].concat(_toConsumableArray(localeMatch)));

                    return country;
                  }
                });

                if (!location.length) {
                  _context2.next = 18;
                  break;
                }

                return _context2.abrupt("return", "".concat(location[0].name, " \u2014 ").concat(location[0].locale[0][1]));

              case 18:
                return _context2.abrupt("return", _localeNameDefault);

              case 19:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function getLangDisplay(_x) {
        return _getLangDisplay.apply(this, arguments);
      }

      return getLangDisplay;
    }()
    /**
     * Get the country list of all supported countries and their languages
     * if it is not already stored in session storage
     *
     * @param {object} params params object
     * @param {string} params.cc country code
     * @param {string} params.lc language code
     *
     * @returns {Promise<any>} promise object
     *
     * @example
     * import { LocaleAPI } from '@carbon/ibmdotcom-services';
     *
     * function async getLocale() {
     *    const list = await LocaleAPI.getList({ cc: 'us', lc: 'en' });
     *    return list;
     * }
     */

  }, {
    key: "getList",
    value: function () {
      var _getList = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(_ref) {
        var _this = this;

        var cc, lc;
        return _regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                cc = _ref.cc, lc = _ref.lc;
                return _context3.abrupt("return", new Promise(function (resolve, reject) {
                  _this.fetchList(cc, lc, resolve, reject);
                }));

              case 2:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3);
      }));

      function getList(_x2) {
        return _getList.apply(this, arguments);
      }

      return getList;
    }()
    /**
     * Fetches the list data based on cc/lc combination
     *
     * @param {string} cc country code
     * @param {string} lc language code
     * @param {Function} resolve resolves the Promise
     * @param {Function} reject rejects the promise
     */

  }, {
    key: "fetchList",
    value: function fetchList(cc, lc, resolve, reject) {
      var _this2 = this;

      var key = cc !== 'undefined' ? "".concat(lc, "-").concat(cc) : "".concat(lc);
      var itemKey = "".concat(_sessionListKey, "-").concat(key);
      var sessionList = this.getSessionCache(itemKey);

      if (sessionList) {
        resolve(sessionList);
      } else {
        if (!_requestsList[key]) {
          var url = "".concat(_endpoint, "/").concat(cc !== 'undefined' ? "".concat(cc).concat(lc) : "".concat(lc), "-utf8.json");
          _requestsList[key] = axios.get(url, _axiosConfig).then(function (response) {
            var data = response.data;
            data['timestamp'] = Date.now();
            sessionStorage.setItem("".concat(_sessionListKey, "-").concat(key), JSON.stringify(data));
            return data;
          });
        }

        _requestsList[key].then(resolve, function (error) {
          if (cc === _localeDefault.cc && lc === _localeDefault.lc) {
            reject(error);
          } else {
            _this2.fetchList(_localeDefault.cc, _localeDefault.lc, resolve, reject);
          }
        });
      }
    }
    /**
     * Verify that the cc and lc combo is in the list of
     * supported cc-lc combos
     *
     * @param {string} cc country code
     * @param {string} lc language code
     * @param {object} list country list
     *
     * @returns {object} object with lc and cc
     * @example
     * import { LocaleAPI } from '@carbon/ibmdotcom-services';
     *
     * async function getLocale() {
     *   const locale = await LocaleAPI.verifyLocale(cc, lc, data);
     *   return locale;
     * }
     */

  }, {
    key: "verifyLocale",
    value: function verifyLocale(cc, lc, list) {
      var priorityLC;
      var locale;
      var language = list && list.regionList.forEach(function (region) {
        return region.countryList.forEach(function (country) {
          var code = country.locale[0][0].split('-');
          var countryCode = code[1];
          var languageCode = code[0];

          if (countryCode === cc && languageCode === lc) {
            locale = {
              cc: cc,
              lc: lc
            };
          } // save the priority language associated with the user's country code
          else if (countryCode === cc && !priorityLC) {
              priorityLC = languageCode;
            }
        });
      });

      if (!language && priorityLC) {
        locale = {
          cc: cc,
          lc: priorityLC
        };
      }

      return locale;
    }
    /**
     * Retrieves session cache and checks if cache needs to be refreshed
     *
     * @param   {string} key session storage key
     * @returns {object} session storage object
     */

  }, {
    key: "getSessionCache",
    value: function getSessionCache(key) {
      var session = typeof sessionStorage === 'undefined' ? undefined : JSON.parse(sessionStorage.getItem(key));

      if (!session || !session.timestamp) {
        return;
      }

      var currentTime = Date.now(),
          timeDiff = currentTime - session.timestamp;

      if (timeDiff > _twoHours) {
        sessionStorage.removeItem(key);
        return;
      }

      return session;
    }
  }]);

  return LocaleAPI;
}();

export default LocaleAPI;