import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _regeneratorRuntime from "@babel/runtime/regenerator";

/**
 * Copyright IBM Corp. 2020, 2021
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */
import axios from 'axios';
import { LocaleAPI } from '../Locale';
import root from 'window-or-global';
/**
 * @constant {string | string} Host for the Translation API call
 * @private
 */

var _host = process && (process.env.REACT_APP_TRANSLATION_HOST || process.env.TRANSLATION_HOST) || 'https://1.www.s81c.com';
/**
 * Translation API default endpoint
 *
 * @type {string}
 * @private
 */


var _ddsEndpointDefault = '/common/carbon-for-ibm-dotcom/translations/masthead-footer';
/**
 * Translation API endpoint
 *
 * @type {string}
 * @private
 */

var _ddsEndpoint = process && (process.env.REACT_APP_DDS_TRANSLATION_ENDPOINT || process.env.DDS_TRANSLATION_ENDPOINT) || _ddsEndpointDefault;
/**
 * Session Storage key for translation data
 *
 * @type {string}
 * @private
 */


var _sessionTranslationKey = 'dds-translation';
/**
 * The cache for in-flight or resolved requests for the i18n data, keyed by the initiating locale.
 *
 * @type {object}
 * @private
 */

var _requestsTranslation = {};
/**
 * Sets the default location if nothing is returned
 *
 * @type {object}
 * @private
 */

var _localeDefault = {
  lc: 'en',
  cc: 'us'
};
/**
 * Two hours in milliseconds to compare session timestamp.
 *
 * @type {number}
 * @private
 */

var _twoHours = 60 * 60 * 2000;
/**
 * Translation API class with methods for fetching i18n data for ibm.com
 */


var TranslationAPI = /*#__PURE__*/function () {
  function TranslationAPI() {
    _classCallCheck(this, TranslationAPI);
  }

  _createClass(TranslationAPI, null, [{
    key: "clearCache",

    /**
     * Clears the cache.
     *
     * @param {string} endpoint specified API non-default endpoint (optional)
     */
    value: function clearCache(endpoint) {
      var sessionKey = this.getSessionKey(endpoint);

      if (typeof sessionStorage !== 'undefined') {
        Object.keys(_requestsTranslation).forEach(function (key) {
          return delete _requestsTranslation[key];
        });

        for (var i = 0; i < sessionStorage.length; ++i) {
          var key = sessionStorage.key(i);

          if (key.indexOf(sessionKey) === 0) {
            sessionStorage.removeItem(key);
          }
        }
      }
    }
    /**
     * Returns translation i18n data
     *
     * @param {object} codes object containing lc and cc
     * @param {string} endpoint endpoint to fetch data from (optional)
     *
     * @returns {Promise<any>} Translation data
     * @example
     * import { TranslationAPI } from '@carbon/ibmdotcom-services';
     *
     * async function getTranslation() {
     *   const response = await TranslationAPI.getTranslation({
     *     lc: 'en',
     *     cc: 'us',
     *   });
     *   return response;
     * }
     */

  }, {
    key: "getTranslation",
    value: function () {
      var _getTranslation = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(codes, endpoint) {
        var _this = this;

        var lang, country, locale;
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                lang = 'en';
                country = 'us';

                if (!(codes && codes.lc && codes.cc)) {
                  _context.next = 7;
                  break;
                }

                lang = codes.lc;
                country = codes.cc;
                _context.next = 12;
                break;

              case 7:
                _context.next = 9;
                return LocaleAPI.getLocale();

              case 9:
                locale = _context.sent;
                lang = locale.lc;
                country = locale.cc;

              case 12:
                return _context.abrupt("return", new Promise(function (resolve, reject) {
                  _this.fetchTranslation(lang, country, endpoint, resolve, reject);
                }));

              case 13:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      function getTranslation(_x, _x2) {
        return _getTranslation.apply(this, arguments);
      }

      return getTranslation;
    }()
    /**
     * Fetches the translation data from sessionStorage or data fetch
     *
     * @param {string} lang Language code
     * @param {string} country Country code
     * @param {string} endpoint endpoint to fetch data (optional)
     * @param {Function} resolve resolves the Promise
     * @param {Function} reject rejects the promise
     * @private
     */

  }, {
    key: "fetchTranslation",
    value: function fetchTranslation(lang, country, endpoint, resolve, reject) {
      var _this2 = this;

      var sessionKey = this.getSessionKey(endpoint);
      var itemKey = "".concat(sessionKey, "-").concat(country, "-").concat(lang);
      var sessionTranslation = this.getSessionCache(itemKey);

      if (sessionTranslation) {
        resolve(sessionTranslation);
      } else {
        var key = country !== 'undefined' ? "".concat(country, "-").concat(lang) : "".concat(lang);

        if (!_requestsTranslation[key]) {
          var regex = /((http(s?)):\/\/)/g; // Check to see if the string from the endpoint variable contains https/http or not.

          var urlEndpoint = endpoint || _ddsEndpoint;
          var locationParam = country !== 'undefined' ? "".concat(country).concat(lang) : "".concat(lang);
          var host = regex.test(endpoint) ? '' : _host;
          var url = "".concat(host).concat(urlEndpoint, "/").concat(locationParam, ".json");
          _requestsTranslation[key] = axios.get(url, {
            headers: {
              'Content-Type': 'text/plain',
              origin: _host
            }
          }).then(function (response) {
            return _this2.transformData(response.data);
          }).then(function (data) {
            data['timestamp'] = Date.now();

            if (typeof sessionStorage !== 'undefined') {
              sessionStorage.setItem("".concat(sessionKey, "-").concat(key), JSON.stringify(data));
            }

            return data;
          });
        }

        _requestsTranslation[key].then(resolve, function (error) {
          if (country === _localeDefault.cc && lang === _localeDefault.lc) {
            reject(error);
          } else {
            _this2.fetchTranslation(_localeDefault.lc, _localeDefault.cc, endpoint, resolve, reject);
          }
        });
      }
    }
    /**
     * sets the Session key depending on API endpoint
     *
     * @param {string} endpoint specified endpoint passed as arg in getTranslation()
     * @returns {string} session key
     * @private
     */

  }, {
    key: "getSessionKey",
    value: function getSessionKey(endpoint) {
      var sessionKey = _sessionTranslationKey; // form session key from specified endpoint

      if (_ddsEndpointDefault !== _ddsEndpoint || endpoint) {
        var endpointSrc = endpoint || _ddsEndpoint;
        sessionKey = endpointSrc.replace(/[`~!@#$%^&*()_|+\-=?;:'",.<>{}[\]\\/]/gi, '');
      }

      return sessionKey;
    }
    /**
     * Transforms translation data
     *
     * @param   {object} data translation data to be transformed
     * @returns {object} Translation data
     * @private
     */

  }, {
    key: "transformData",
    value: function transformData(data) {
      var _data$profileMenu;

      var signedout = (_data$profileMenu = data.profileMenu) === null || _data$profileMenu === void 0 ? void 0 : _data$profileMenu.signedout;

      if (signedout) {
        var strReplace = 'state=https%3A%2F%2Fwww.ibm.com';
        var loginIdx = signedout.findIndex(function (elem) {
          var _elem$url;

          return ((_elem$url = elem.url) === null || _elem$url === void 0 ? void 0 : _elem$url.indexOf(strReplace)) !== -1;
        });

        if (loginIdx !== -1 && root.location) {
          var location = encodeURIComponent(root.location.href);
          data.profileMenu.signedout[loginIdx].url = signedout[loginIdx].url.replace(strReplace, "state=".concat(location));
        }
      }

      data.footerMenu.push(data.socialFollow);
      return data;
    }
    /**
     * Retrieves session cache and checks if cache needs to be refreshed
     *
     * @param   {string} key session storage key
     * @returns {object} session storage object
     * @private
     */

  }, {
    key: "getSessionCache",
    value: function getSessionCache(key) {
      var session = typeof sessionStorage === 'undefined' ? undefined : JSON.parse(sessionStorage.getItem(key));

      if (!session || !session.timestamp) {
        return;
      }

      var currentTime = Date.now(),
          timeDiff = currentTime - session.timestamp;

      if (timeDiff > _twoHours) {
        sessionStorage.removeItem(key);
        return;
      }

      return session;
    }
  }]);

  return TranslationAPI;
}();

export default TranslationAPI;